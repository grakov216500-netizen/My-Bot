# Диагностика напоминаний бота

Пошаговая проверка, почему напоминания (о нарядах или о задачах) не приходят вовремя.

---

## 1. Напоминания о нарядах (за 2 дня и в день наряда)

**Где логика:** `handlers/reminders.py` — создаёт задачи через `job_queue.run_once(send_duty_reminder, when=...)`.  
**Восстановление:** при старте бота вызывается `restore_duty_reminders()` из `main.py` (post_init).

### Шаг 1. Есть ли график в памяти бота?

- При загрузке Excel график попадает в `bot_data['duty_schedule']`.
- При старте бота графики подгружаются из `utils/storage.load_all_schedules()` в `bot_data['schedules']` и `duty_schedule`.

**Проверка:** В логах при старте должно быть что-то вроде:
```text
Загружено N расписаний. Активно: 2025-12
```
или
```text
Нет сохранённых графиков
```
Если «Нет сохранённых графиков» — напоминания о нарядах не создаются. Загрузите график через бота (Excel) или убедитесь, что `data/schedules` (или то, что использует storage) содержит актуальный график.

### Шаг 2. Сохраняется ли bot_data (persistence)?

Напоминания хранятся в памяти в `bot_data['reminder_jobs']`. При перезапуске бота **job'ы не восстанавливаются из pickle** — восстанавливаются только данные графика (`duty_schedule`), а по ним заново вызывается `create_duty_reminders()`.

**Проверка:** После перезапуска в логах должно быть:
```text
Восстановление напоминаний для N записей
Восстановлено M напоминаний о нарядах
```
Если N = 0 — в `duty_schedule` пусто (см. шаг 1).

### Шаг 3. Найден ли chat_id по ФИО?

В `create_duty_reminders` для каждой записи вызывается `find_chat_id_by_fio(fio)`. Поиск идёт по **фамилии** (первое слово ФИО) в таблице `users`.

**Проверка:** В логах при создании напоминаний:
- `Не найден chat_id для: Фамилия Имя Отчество` — пользователь не зарегистрирован в боте или ФИО в графике не совпадает с ФИО в БД (регистрация).
- `Напоминание за 2 дня: ФИО → 2025-12-24 20:00:00` — запись создана.

**Что сделать:** ФИО в загруженном Excel должно совпадать с ФИО при регистрации (хотя бы фамилия). Проверьте таблицу `users`: есть ли там запись с нужным `fio` и `telegram_id`.

### Шаг 4. Часовой пояс и время отправки

`run_once(when=remind_time)` использует **локальное время сервера** (или UTC, в зависимости от того, как создаётся `datetime`). В коде время задаётся как `datetime.combine(date, time("20:00"))` без timezone — значит, время сервера.

**Проверка:** Узнайте часовой пояс сервера (где крутится бот). Если сервер в UTC, а вы в МСК (UTC+3), напоминание «в 20:00» уйдёт в 20:00 UTC = 23:00 МСК.

**Что сделать:** Либо поднимать бота на сервере в вашем часовом поясе, либо задавать время в коде с учётом timezone (например, через `datetime(timezone=...)` и при создании job передавать timezone-aware datetime, если библиотека это поддерживает).

### Шаг 5. Бот не перезапускался в момент срабатывания

JobQueue работает только пока процесс бота запущен. Если бот перезапустили или упал незадолго до времени напоминания, job теряется. После старта создаются только те напоминания, у которых `when` ещё в будущем.

**Проверка:** Смотрите логи перезапусков и падений (Replit, systemd, Docker и т.д.).

### Шаг 6. Пользователь заблокировал бота

При отправке может быть ошибка `Forbidden: bot was blocked by the user`. В коде это логируется, но job уже не повторяется.

**Проверка:** В логах в момент времени напоминания ищите строки с `bot was blocked` и `chat_id`.

---

## 2. Напоминания о задачах (задачи с дедлайном)

**Где логика:**  
- **Сервер (рекомендуется):** В `server.py` при старте FastAPI запускается фоновый поток `_task_reminders_loop()`: каждые 30 сек проверяются задачи с дедлайном в окне ±90 сек, отправка через Telegram Bot API, затем `reminded = 1`. **Не зависит от процесса бота** — напоминания приходят даже при перезапуске бота, если сервер запущен и задан `BOT_TOKEN`.  
- **Бот (дублирование):** `handlers/task_reminders.py` — `check_task_reminders()` каждые 30 сек и `restore_task_reminders()` при старте создаёт `job_queue.run_once(...)`.

**Чтобы работал серверный планировщик:** В окружении процесса, где запущен FastAPI (uvicorn), должен быть задан тот же `BOT_TOKEN`, что и у бота. При старте сервера в логах: `[OK] Планировщик напоминаний о задачах запущен (каждые 30 сек)` или `[WARN] BOT_TOKEN не задан — напоминания о задачах отправляет только бот`.

### Шаг 1. Задача сохранена с дедлайном

В БД в таблице `tasks` у записи должны быть: `deadline` (не NULL), `done = 0`, `reminded = 0`.

**Проверка (SQL):**
```sql
SELECT id, user_id, text, deadline, reminded, done FROM tasks WHERE deadline IS NOT NULL AND done = 0;
```

### Шаг 2. Формат дедлайна

В коде используется `datetime.fromisoformat(deadline)`. Ожидается формат типа `YYYY-MM-DD HH:MM:SS` (с пробелом). Если в БД или API передаётся другой формат (например, только дата), парсинг или окно проверки могут работать неверно.

**Проверка:** Посмотреть, что реально записано в `tasks.deadline` после установки напоминания из Mini App.

### Шаг 3. Job при перезапуске бота / серверный планировщик

При перезапуске бота все «разовые» job'ы теряются. Если напоминания должны работать **независимо от бота**, запускайте FastAPI (server.py) с переменной окружения `BOT_TOKEN` — тогда фоновый планировщик на сервере каждые 30 сек проверяет дедлайны и отправляет напоминания. Бот при старте по-прежнему вызывает `restore_task_reminders()` для своих job'ов; можно оставить как дублирование или не полагаться на него.

**Проверка (бот):** В логах при старте бота:
```text
Восстановлено N напоминаний
```
**Проверка (сервер):** В логах при старте сервера:
```text
[OK] Планировщик напоминаний о задачах запущен (каждые 30 сек)
```
Если после установки напоминания бот перезапускали, серверный планировщик всё равно отправит напоминание в момент дедлайна (в окне ±90 сек).

### Шаг 4. user_id в tasks = telegram_id

В таблице `tasks` поле `user_id` должно совпадать с `telegram_id` пользователя в Telegram (на него отправляется сообщение). Если при сохранении задачи из Mini App подставился внутренний `id` из таблицы `users` вместо `telegram_id`, сообщение уйдёт не тому или не уйдёт.

**Проверка:** Сравнить `tasks.user_id` и `users.telegram_id` для тестового пользователя.

### Шаг 5. Окно 30 сек и ±90 сек

`check_task_reminders` запускается каждые 30 секунд и выбирает задачи, у которых дедлайн попадает в окно [now - 90 сек, now + 90 сек]. Если сервер сильно отстаёт или убегает по времени, окно может «промахнуться».

**Проверка:** Вывести в лог текущее время сервера и выбранные дедлайны при одном срабатывании проверки.

---

## 3. Краткий чек-лист

| Проверка | Наряды | Задачи |
|----------|--------|--------|
| Данные есть (график / задача с дедлайном) | duty_schedule не пустой | tasks.deadline не NULL, reminded=0 |
| Получатель найден | find_chat_id_by_fio → users.telegram_id | tasks.user_id = telegram_id |
| Время и часовой пояс | Сервер в нужном поясе / время 20:00 и 06:00 | Дедлайн в формате ISO, сервер не ушёл по времени |
| Бот не падал/не перезапускался | — | Серверный планировщик (server.py + BOT_TOKEN) не зависит от бота |
| Пользователь не блокировал бота | Логи Forbidden | Логи Forbidden |

Если после всех шагов напоминания всё равно не приходят — включите подробное логирование (DEBUG) в `reminders.py` и `task_reminders.py` и повторите сценарий с одним нарядом и одной задачей с дедлайном через 2–3 минуты.
